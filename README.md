# Week19
// --------------------- Вопрос 1 --------------------- //
Асинхронный код - это код. который выполнится когда-то в будущем, например, setTimeout.
Синхронный код - выполняется последовательно, вторая операция не будет выполнена, пока исполняется первая.

// --------------------- Вопрос 2 --------------------- //
1)Callback (функция обратного вызова) — это функция, которая передается внутри другой функции, а затем вызывается в этой функции для выполнения задачи.
console.log('fired first');
console.log('fired second');

setTimeout(()=>{
    console.log('fired third');
},2000);

console.log('fired last');

setTimeout — это функция, которая принимает два параметра:
Первый параметр — это другая функция,
а второй — время, по истечении которого эта функция должна выполняться в миллисекундах.
Но, чтобы сделать эти вызовы, обратные вызовы вкладывают друг в друга до тех пор, пока их не станет очень трудно читать или поддерживать.

2)Promise — это то, что требует некоторого времени для выполнения. Promise принимает две функции в качестве параметров: resolve() — это успех, reject() — при возникновении ошибки.
const getData = (dataEndpoint) => {
   return new Promise ((resolve, reject) => {
     //some request to the endpoint;
     
     if(request is successful){
       //do something;
       resolve();
     }
     else if(there is an error){
       reject();
     }
   
   });
};
Этот метод можно использовать для последовательного получения данных из нескольких конечных точек, но с меньшим количеством кода и более простыми методами.

3)для того, чтобы объединение обещаний вместе, как и обратных вызовов, может стать довольно громоздким и запутанным. Вот почему были созданы Async и Await.
const asyncFunc = async () => {
	const response = await fetch(resource);
   	const data = await response.json();
}
Ключевое слово async — это то, что используем для определения асинхронных функций.
Await останавливает JavaScript от назначения fetch переменной ответа до тех пор, пока обещание не будет разрешено. Как только обещание было разрешено, результаты метода выборки теперь могут быть назначены переменной ответа.

// --------------------- Вопрос 3 --------------------- //
Event Loop - это специальный механизм на уровне движка js, который координирует работу трёх сущностей: Call Stack (стэк вызовов), Web API (API, предоставляемый браузером), Callback Queue (очередь колбэков).

Работают они следующим образом: движок js анализирует код. Когда он встречает вызов какой-то функции, он перемещает эту функцию в Call Stack. Если эта функция синхронная (например, console.log()), то она сразу же исполняется, покидает стэк и на её место приходит следующая функция. Если же эта функция асинхронная, например, setTimeout(), обработчик событий, сетевой запрос и т.д., то на помощь приходит браузер со своим Web API. Event Loop перемещает колбэк асинхронной функции в Web API, а сама асинхронная функция уходит из стэка вызовов. То есть, пока колбэк асинхронной функции находится под управлением Web API, движок js продолжает выполнять другие операции!

Что происходит с колбэком? В случае, например, setTimeout(), Web API ожидает истечения указанного времени, затем Event Loop перемещает этот колбэк в Callback Queue (очередь колбэков). Когда стэк вызовов освобождается, Event Loop перемещает в него наш колбэк из очереди колбэков, после чего колбэк наконец исполняется и покидает стэк вызовов.

Этот процесс повторяется до тех пор, пока весь js код не будет выполнен.

// --------------------- Вопрос 4 --------------------- //
Цикл событий - это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то функция удаляется из очереди и помещается с стек вызовов для выполнения.

Stack - “первым пришел, последним вышел” или “последним пришел, первым вышел”.
Queue - “первым пришел, первым ушел”.

// --------------------- Вопрос 5 --------------------- //
1)Стандарт HTTP/0.9 – версия протокола HTTP 0.9 была разработана в 1991 году в ЦЕРН Тимом Бернерсом-Ли. Тим разработал HTTP протокол для облегчения доступа и создания навигации при помощи гипертекста. Протокол версии 0.9 был призван упорядочить взаимодействие между клиентом и сервером в сети. После появления стандарта HTTP/0.9 появилось разделение функций между клиентом и сервером при их взаимодействии. Стандарт HTTP/0.9 содержит в себе основы синтаксиса и семантики протокола HTTP.
2)В 1996 году был выпущен информационный документ RFC 1945 (стандарт HTTP/1.0). Данный документ стал основой для реализации приложений и компонентов с использованием протокола HTTP версии 1.0. Кстати, разработчики могут идентифицировать свои приложения при передаче HTTP сообщений.
3)В 1997 году была выпущена версия протокола HTTP1: был разработан стандарт HTTP/1.1 и описан он в документе RFC 2068. В 1999 году был доработан стандарт HTTP/1.1 (именно стандарт HTTP/1.1). Доработки коснулись: общего дизайна стандарта, формулировки и разъяснения некоторых терминов, исправлены опечатки, даны некоторые разъяснения по взаимодействию клиента и HTTP сервера в спорных ситуациях. Основным нововведением в версию протокола HTTP 1.1 был режим постоянного соединения (можете почитать про постоянные HTTP соединения), другими словами: за одно соединение можно было отправлять несколько HTTP запросов и получать несколько HTTP ответов в том порядке, в котором делались запросы. Вторым основным нововведение в версию протокола HTTP 1.1 является то, что теперь клиент при установке соединения с сервером должен обязательно посылать имя хоста в специальном поле HTTP заголовка (данное нововведение привело к массовому распространению виртуальных хостингов). На данный момент большинство приложений для своей работы используют HTTP протокол версии 1.1. Стоит заметить, что версия HTTP протокола является очень важным HTTP параметром, который должны использовать все приложения. Так же замечу, что независимо от номера стандарта HTTP протокол предъявляет требования к приложениям, которые его используют.
4)D 2015 году была опубликована финальная версия черновика протокола HTTP 2, это еще не стандарт, но черновик нам «показывает» куда будет двигаться развитие интернета. Версия протокола HTTP 2 является бинарной. В версии протокола HTTP 2 будет поддерживаться мультиплексирование (объединение) запросов, поскольку появится объединение, появится и приоритет запросов и многое другое, думаю, в завершении цикла заметок по HTTP мы познакомимся со всеми нововведениями HTTP.

// --------------------- Вопрос 6 --------------------- //
Информационные 100 - 199
Успешные 200 - 299
Перенаправления 300 - 399
Клиентские ошибки 400 - 499
Серверные ошибки 500 - 599

// --------------------- Вопрос 7 --------------------- //
Клиенты и серверы обмениваются сообщениями в шаблоне запрос-ответ. Клиент отправляет запрос, а сервер возвращает ответ. Этот обмен сообщениями является примером межпроцессного взаимодействия. Для взаимодействия компьютеры должны иметь общий язык, и они должны следовать правилам, чтобы и клиент, и сервер знали, чего ожидать. Язык и правила общения определены в протоколе связи. Все протоколы клиент-серверной модели работают на уровне приложений. Протокол прикладного уровня определяет основные шаблоны диалога. Чтобы ещё больше формализовать обмен данными, сервер может реализовать интерфейс прикладного программирования (API). API — это уровень абстракции для доступа к сервису. Ограничивая связь определённым форматом контента, он облегчает синтаксический анализ. Абстрагируя доступ, он облегчает межплатформенный обмен данными.

// --------------------- Вопрос 8 --------------------- //
CORS (Cross-Origin Resource Sharin) – совместное использование ресурсов между разными источниками — это механизм, который дает разрешения на загрузку ресурсов из одного источника в другой, сохраняя при этом целостность сайта и защищая его от несанкционированного доступа. Современные браузеры используют это, чтобы определить, какие межсайтовые запросы безопасны.
CORS — это способ улучшить защиту вашего веб-приложения на стороне клиента, но его нельзя использовать в качестве единственного уровня защиты.
Mеры защиты для вашего сайта:
-не используйте подстановочный знак «*», чтобы не допустить каждому загружаемому сценарию связываться с ресурсом;
-проверяйте все заголовки запросов управления доступом по соответствующим спискам доступа;
-попробуйте простое, но безопасное сравнение строк с массивом доверенных значений, чтобы снизить риск;
-используйте как можно больше уровней защиты;
-регулярно применяйте обновления с исправлениями уязвимостей ПО;
-настройте правила управления доступом;
-используйте брандмауэр веб-сайта.

// --------------------- Вопрос 9 --------------------- //
REST API — это способ взаимодействия сайтов и веб-приложений с сервером. Его также называют RESTful.
Технологию REST API применяют везде, где пользователю сайта или веб-приложения нужно предоставить данные с сервера. Например, при нажатии иконки с видео на видеохостинге REST API проводит операции и запускает ролик с сервера в браузере. В настоящее время это самый распространенный способ организации API. Он вытеснил ранее популярные способы SOAP и WSDL.

// --------------------- Вопрос 10 --------------------- //
Открываем нужную страницу, нажимаем F12 и открываем консоль. Далее, в консоли выбираем логирование "Запросов" и обновляем страницу, после этого, можно будет посмотреть заголовки.

// --------------------- Вопрос 11 --------------------- //
можно указывать тип запроса или передаваемых на сервер данных.

// --------------------- Вопрос 12 --------------------- //
fetch('localhost/pets/add', {
  method: 'POST',
  body: JSON.stringify({
        "breed": "Beagle",
		"size": "large",
		"color": "orange",
		"age": 6
  })
});